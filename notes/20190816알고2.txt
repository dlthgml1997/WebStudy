IM 준비 : 11로봇 13빌딩 21소금중첩 22소금합계 32점프사방 42미로도착지점

Math&Probability는 컴퓨테이셔널 띵킹하고 비슷해서 안함, 근사법(답에 가까워지게 연산), 기본확률법칙
	분할정복 백트래킹 DP
배열차수는 낮추고, 클래스(스태틱) 변수보다 인스턴스 변수보다 로컬변수 -> 메모리 복잡도를 낮춘다.
힙보다 스택보다 레지스터사용 하는 것이 시간을 줄인다.
-0을 없앤 n의 보수 표현
float(4바이트):유효 자릿수 6/double(8바이트):유효 자릿수 15 - 부동소수점 
	
	<<완전검색&그리디(회의실 배정하기 - Comparable, Comparator)>>
<반복> "for/while"
조건검사변수초기화-while(조건검사)-{반복할명령문실행, 조건검사변수업데이트}
DP
무한 반복시 CPU를 반복해서 점유
<재귀> 함수내부에서 자기자신을 호출하는 함수 - "함수호출은 반복적으로 스택사용!' (백트래킹으로 성능개선)
*두부분을 "if else"문으로 표현 -> 각각 내부에 return문이 있어야함! (else는 생략)
-Basis : induction생성 위한 seed역할(꼭 지정해주어야함) base케이스에서 호출이 종료된다!
-Inductive : 점화식
(basis를 잘못 잡거나 해서)무한 반복시 스택오버플로우 발생
문제)gcd, 하노이탑, nqueen

	<완전검색>
느리지만 답 나올 확률이 높다, 일단 완전검색으로 풀고 다른 알고리즘써서 답비교
조합적문제들(순열/조합/부분집합)에 대한 bruteforce방법
	<순열> 주사위 던지기 1,2
nPr = n*(n-1Pr-1)
최소한의 변경으로 순열을 생성하는 방법(종소리 패턴 스왑)
powerset을 0,1의 중복순열로 구할 수도 있다~
문제)여행사(=TSP) n! n이커지면 기하급수적으로 시간이 증가
	<조합> 1810백설공주
nCr=n-1Cr-1 + n-1Cr (특정하나를 포함해서 뽑는 경우의 수+아닌 경우의 수)
	
	<그리디(탐욕)> Top-Down
매 단계에서 가장 좋아보이는 것을 빠르게 선택(local optimal choice)
최적해를 구한다는 보장X
문제)냅색(DP로 풀수도 있음), 동전자판기, 회의실배정은 sort(컴패러블, 컴패래터 등 정렬 규칙)
	<DP 동적계획법> Bottom-up
매 단계의 선택은 해결한 하위 문제의 해를 기반