
오버로딩 은 1.메서드 이름이 같고 2."파라메터만 다른" 메서드를 여러개 만드는 것
	리턴타입이나 수식어는 상관없다!!

"물려받은 메서드를 재정의" 하는 오버라이딩은 메소드이름, 파라메터, 리턴타입등 "{}밖은 전부 같아야한다!!!!" {안}은 상관없음
	수식어("접근지정자)는 달라도 되는데" 부모의 범위와 같거나 넓어지는건 괜찮다.(범위가 좁아지면 안된다!!!!)

생성자 내부에서만 사용되는 this()메서드. 그 파라메터와 맞는 다른 생성자를 부르는 메서드.
<캡슐화> = 정보은폐=Encapsulation
private이용 
	ex. 데이터는 private로 해놓고 게터와 세터 메서드를 public으로 놓아 접근 할 수 있게 해둔다.

자식클래스는 부모클래스+추가/변경사항~

super.는 부모 클래스를 의미
	Child c = new Child(); //go를 오버라이딩 한 경우
		c.go()하면 Childe에서 오버라이딩된 go()를 의미
		super.go()하면 오버라이딩 전 원래 있던 Parent의 go()를 의미(따라서 부모의 go와 내가 쓴 go 둘다 가지고 있음!!)

생성을 막아놓기 위해 abstract 클래스로 지정할 수 있다. 

추가 -Other -AmatersUML-class diagram

Generalization(실선화살표) extends  <is-a 관계>
Realization(점선화살표) implements 
Aggregation(하얀마름모화살표) 어떤 다른 클래스를 멤버필드에 가지고 있는지 확인 <has-a관계>
Dependency(점선화살표) 어떤것에 의존적인지 확인가능(메인이 어떤 클래스에 의존적, 어떤클래스를 생성한다)
색깔은 초노파빨 순서

Parent s = new Child(); 	////s는 페런트 타입이지만 차일드에서 오버라이딩된 함수가 호출됨!!!! 
			////오버라이딩되지않고 원래 부모타입에 없고 자식에만 있는 함수를 호출하면 에러가 생김!!!!
			////필드는 이름이 같은 필드가 자식에 있어도 Parent의 필드가 사용됨!!!!(=필드는 오버라이딩 대상이 아니다)
			////s instance of Child -> 참!!!(내용물이 차일드이니까)
Child p = (Child)s; //이건 충분히 가능한 형변환 데이터 손실x

Parent s = new Parent();
Child x = (Child)s; //상위를 하위타입으로 형변환시킴. 컴파일은 되지만, 
		//오버라이딩된 함수의 정보가 없으므로 에러가 생길것임

자식은 부모의 것에 접근가능, 부모는 자식 메서드 등에 접근 불가능.

참고)float타입숫자 뒤에 f붙여야함. char타입인데 ''면 에러남(char는 내용이 항상1개여야함)

)클래스이름만(레퍼런스만) sysout에 찍으면 뒤에 자동으로 .toString()메소드가 호출된다~~

)지역변수는 초기화하지 않으면 사용할때 컴파일에러가 발생한다!

)if(z++>0 && 블라블라)일 왼쪽이 거짓이면 z에다 1만더해지고 블라블라는 보지도않음.

)부모에 default생성자가 없으면 자식을 생성할 때 부모가 자동으로 생성되지 않는다!!!!!!!!!!! ->컴파일 오류 발생
	->자식의 생성자를 만들면서 부모생성자의 파라메터에 super로 전달해주어야 부모가 생성가능하다!!!!!!!!!!!!