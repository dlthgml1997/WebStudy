오버로딩은 1.메서드 이름이 같고 2."파라메터만 다른" 메서드를 여러개 만드는 것
	리턴타입이나 수식어는 상관없다!!

"물려받은 메서드를 재정의" 하는 오버라이딩은 메소드이름, 파라메터, 리턴타입등 "{}밖은 전부 같아야한다!!!!	"
	수식어("접근지정자)는 달라도 되는데" 부모의 범위와 같거나 넓어지는건 괜찮다.(범위가 좁아지면 안된다!!!!)

생성자 내부에서만 사용되는 this()메서드. 그 파라메터와 맞는 다른 생성자를 부르는 메서드.
<캡슐화> = 정보은폐=Encapsulation
private이용 
	ex. 데이터는 private로 해놓고 게터와 세터 메서드를 public으로 놓아 접근 할 수 있게 해둔다.

자식클래스는 부모클래스+추가/변경사항~

super.는 부모 클래스를 의미
	Child c = new Child(); //go를 오버라이딩 한 경우
		c.go()하면 Childe에서 오버라이딩된 go()를 의미
		super.go()하면 오버라이딩 전 원래 있던 Parent의 go()를 의미(따라서 부모의 go와 내가 쓴 go 둘다 가지고 있음!!)

생성을 막아놓기 위해 abstract 클래스로 지정할 수 있다. 

추가 -Other -AmatersUML-class diagram

Generalization(실선화살표) ParentClass로 연결 <is-a 관계>
Realization(점선화살표) Interface로 연결
Aggregation(하얀마름모화살표) 어떤 다른 클래스를 멤버필드에 가지고 있는지 확인 <has-a관계>
Dependency(점선화살표) 어떤것에 의존적인지 확인가능(메인이 어떤 클래스에 의존적, 어떤클래스를 생성한다)
색깔은 초노파빨 순서

Parent s = new Child(); 	////s는 페런트 타입이지만 차일드에서 오버라이딩된 함수가 호출됨!!!! 
			////오버라이딩되지않고 원래 부모타입에 없고 자식에만 있는 함수를 호출하면 에러가 생김!!!!
			////필드는 이름이 같은 필드가 자식에 있어도 Parent의 필드가 사용됨!!!!
			////s instance of Child -> 참!!!(내용물이 차일드이니까)
Child p = (Child)s; //이건 충분히 가능한 형변환 데이터 손실x

Parent s = new Parent();
Child x = (Child)s; //상위를 하위타입으로 형변환시킴. 컴파일은 되지만, 
		//오버라이딩된 함수의 정보가 없으므로 에러가 생길것임

참고)float타입숫자 뒤에 f붙여야함. char타입인데 ''면 에러남(char는 내용이 항상1개여야함)

)클래스이름만(레퍼런스만) sysout에 찍으면 뒤에 자동으로 .toString()메소드가 호출된다~~

)지역변수는 초기화하지 않으면 사용할때 컴파일에러가 발생한다!

)if(z++>0 && 블라블라)일떄 왼쪽이 거짓이면 z에다 1만더해지고 블라블라는 보지도않음.

)부모에 default생성자가 없으면 자식을 생성할 때 부모가 자동으로 생성되지 않는다!!!!
	->자식의 생성자를 만들면서 부모생성자의 파라메터에 super로 전달해주어야 부모가 생성가능하다!!!!

업로드 목록 : Second Project,java 06, wsjava05, hwjava05, 오늘 필기, java.zip