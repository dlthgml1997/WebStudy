	<DP> Recursive+Memoization
점화식을 찾고 완전검색을 하지만 재귀호출이 아닌 "반복문"으로 좀더 효율적인 방법 사용
최적화문제 해결
ex)피보나치 수열을 재귀로 하면 중복호출이 많음 -> Memoization(메모리 공간 추가/재귀로 인한 시스템호출 스택 사용함..)
	피보나치를 재귀로 하면 최소 2^(n/2)인데 DP로 최소가능횟수인 n번보다 크다.

수학적 귀납법>
	n=1or0 일때 성립함을 증명. (귀납기본)
	n일 때 성립한다고 가정(귀납가정)했을 때 n+1일 때 성립함을 증명(귀납단계)
	-> 모든 n에 대해 성립함을 증명함

	<DP 적용 요건>
1. "중복" 부분문제 구조(Overlapping subproblems)
	작은 문제의 해를 저장해 두고 이것을 더 큰문제의 해를 구할 때 참조해서 사용( =점화식 = 순환적 관계)
2. "최적" 부분문제 구조(Optimal substructure)
	큰문제의 최적해가 작은문제들의 최적해로 구성되어야 함!! ex)최장경로문제는 풀 수 없다.

DP = 분할정복+메모이제이션+상향식	
	
	<DP 접근 단계>
1.부분문제로 나눈다.
2.재귀적으로 최적해 값을 정의(점화식)
3.상향식방법으로 최적해 계산

	<이항계수>
(x+y)^n에서 x^k * y^(n-k)의 계수는 nCk

	<상태 공간 트리(State-space tree)>
