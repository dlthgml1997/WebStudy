어드 : 순열조합, DFSBFS, 등등 + 가지치기

	<백트래킹> = DFS에서 완탐 도중에 가지치기
ex)NQueen

	<그래프> DFS/BFS p.264
정점(Vertex=아이템)와
간선(Edge=연결관계)로 트리로 표현하기 어려운 N:N관계 표현
|V| = 정점 개수
최대 간선 개수 = vC2 = |V|(|V|-1)/2
|E| = 간선 개수(완전그래프면 최대값을 가짐)

인접 = 간선 존재, 1
간선 정보의 표현
	인접행렬 (|V|*|V|) 
		방향이 없으면 중앙 기준 양쪽(무향), 있으면 한쪽만(유향-> 행/렬의 1을 세서 진출/진입차수를 구할 수 있다.)
		단점 메모리 공간 많이 차지, 간선의 배열로 저장할수 도 있다.
	인접리스트 .append
		기준 정점 리스트에 무향이면 양쪽으로 다 이어줌 <- ->, 유향은 한쪽에만 등록
	<서로소집합 Disjoint-set> : 상호배타 즉, 서로 교집합이 없다
그래프가 사이클이 되는지 여부를 확인할 때 쓰임 (크루스칼 알고리즘)
Make-Set(x) : 새로운 집합 생성(원소 1개)
Find-Set(x) : 부모가 누군지 리턴(부모가 다르면 서로 다른 집합에 있다.)
Union(x,y) : 두 집합중 한쪽의 대표값을 대표값으로 모두 가지게 해서 집합을 통합
		p[Find-Set(y)] = Find-Set(x)
		랭크(depth) 낮은 집합y을 높은 집합x에 붙임(작은놈을 큰놈에 붙임) - 랭크가 증가하는 것을 방지

연결리스트 - 양방향 링크로 하나는 다른원소 하나는 부모를 가르키게함
트리 - 부모노드를 가르키며 루트노드가 대표자(=자기 자신을 가르킴!) -> 트리의 배열로 저장한다. 
	ㄴPath compression : 부모를 쭉 따라가면 루트가 나오는데 루트를 바로 가르키도록 부모를 갱신하는 것 p[x] = FIndSet(p[x]) 