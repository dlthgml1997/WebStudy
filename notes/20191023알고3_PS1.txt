숨어있는 테스트 케이스 찾을 때 
입력조건의 하한값 및 상한값을 
랜덤으로 테케 만들어서 체크

그리디보다는 완탐(dfs,bfs)으로 상태공간트리의 모든 경우 체크

테케 분석먼저 하고 코딩하기
------
log의 밑이 2 (e나 10아님!)
------
증명 보기. 상식선(직관)에서 이해되는 분야는 없다.

---
inclusive or는 중간 포함 / exclusive or(XOR)은 중간 포함X
--
	<명제> "p가 거짓이거나 q가 참이라면 항상 참!!"
p   ->    q	식
T	T	T
T	F          "F"!!
F	T	T
F	F	T

"~q  ->  ~p" 도 3개 참거짓이 동일!!!!이므로 어떤 식을 "대우"로 만들어서 확인해도 된다!

//p->q는 ~pVq와 동치
-----
	<진리표>
v 는 OR(합)
^ 는 AND(교)

---
	<증명>ex)소수는 무한히 많다~
대우명제를 증명해도 된다
경우의 수를 나누어 증명(짝수 or 홀수), 나머지의 경우
귀류법
수학적 귀납법>21번
	P(1)이 참이고 P(n) "->" P(n+1)이 "참!"이면 
		P(n)은 모든 자연수에 대해 참이다.
	P(n)을 직접 증명하지 않고 ->가 참인 것만 증명하면 된다 (블랙박스)

//재귀호출에 수학적귀납법이 사용됨!
---
	<마방진>
홀수마방진 코딩
	모든 행/열/대각선의 합이 같다
---
	<GCD,LCM>
a * b = gcd * lcm;

gcd공식(유클리드 호제법)>
*gcd(a,b) = gcd(b,a%b)*
gcd(a,0) = a
-----
	<이항계수>
(부분집합은 이항계수와 비슷함)
일반항 알아두기!!>
	(a+b)^n = (r이 0부터 n까지) nCr*a^n*b^n-r
-----------------
조합 코딩 참고
	*<모듈라 연산>* mod n 또는 %n
정수를 0~n-1로 표현할 수 있음
a mod n = b mod n
a ≡ b (mod n) : 두 정수 a, b는 modula n에 대해 합동. 즉, n으로 나눈 나머지가 같다는 뜻!!

공식>
(a+b)%n = (a%n + b%n)%n
(a-b)%n = (a%n - b%n)%n
(a*b)%n = (a%n * b%n)%n
	지수연산은 곱셈의 연산이므로 빠르게 수행 가능

	**<Fermat Little Theorem>**
		(mod p)
a^p ≡ a (mod p)
a^(p-1) ≡ 1 (mod p)
a^(p-2) ≡ 1/a (mod p)
------------------

n^n > n!
