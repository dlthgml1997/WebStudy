graph의 unionfind는 알아두어야함(이걸로만 빠르게 풀리는 문제가 있음)


	<최소신장트리>
신장 트리 = "n개의 점"으로된 무향 그래프의 모든 점들을 한번이상 모두 연결("간선이 n-1")한 트리
		순환경로가 없으며 트리가 된다.
	->"간선의 가중치 합이 최소"면 최소신장트리

Prim : 시작정점부터 모든 정점에 대해 greedy 탐색하면서 "유니온"으로 연결(사이클이 발생되지 않도록 부모가 다를 경우만!, n-1간선까지) weight 1차원 배열
Kruscal : "가중치가 가장 낮은 간선부터 차례로" 선택하면서 "유니온"으로 연결(사이클이 발생되지 않도록 부모가 다를 경우만!, n-1간선까지)

정점개수가 10^5가 넘어가면 인접행렬이 아닌 인접리스트로 표현

	<최단 경로>
두 정점 사의 경로 중 "간선의 가중치의 합이 최소"인 경로
Daijkstra : greedy로 "출발지에서 각각의 정점"으로 가는 "최단경로"를 계속 업데이트한다. distance 1차원 배열

---------------------------------------
	<해시>(해시맵, 해시셋)
*equals&해쉬코드를 꼭 오버라이딩!!!!해야 중복체크가 된다.
탐색키 --> |해시함수| --> 해시주소(해시값) --> 해시테이블
	
	<충돌> 서로 다른 탐색키가 같은 해시 주소를 가르킬 경우
해결방법 	1. 체이닝(링크드리스트로 해시테이블에 늘려 붙인다.)
	2. 개방주소법(1차원 배열로 빈공간이 나올때까지 테이블의 다음을 탐색해서 넣는다.)
---------------------------------------

	<패턴 매칭>
브루트포스, 라빈-카프(패턴과 해시값이 같은 부분만 비교(한글자씩넣고뺀 다음 해시를 빠르게 계산), but 해시가 같아도 문자열은 다를 수 있음=충돌), 
KMP(패턴의 전처리 O(M+N)), 보이어-무어(전처리 후 맨 오른쪽 글자만 확인후 다르면 그 글자와 같은 패턴까지 스킵, 패턴에 없게 다르다면 통째로 스킵)

	<트라이>문자열의 집합을표현하는 트리 (Retrieve)
모든 문자열은 다른 문자열의 접두어가 아니라고 가정. 
리프노드가 문자열
	<접미어 트리 suffix tree>
- 모든 접미사를 리프로 가짐(길이s면 리프 s개) 문자열의 마지막에 $하나를 붙임(사전순으로 제일먼저오는 문자)
접미어 트리의 생성 : Trivial 알고리즘 O(n)

접미사 트라이로 "문자열 연산" : 부분문자열, 최장공통접두사 찾기, k번째접미사, 사전적순서로 정렬 등
	Compressed Trie : 부분문자열로 압축할 수 있다. 

	<접미어 배열>(공간복잡도를 줄이기 위한 접미어 배열로 표현가능. but 접미어 트리보다 느리다)
메모리 O(n) 시간 O(nlogn)
	최장공통접두어 LCP> 
정렬된 접미어 배열에서 연속된 2개 접미어의 일치 문자수 비교해서 최대값을 구한다.

